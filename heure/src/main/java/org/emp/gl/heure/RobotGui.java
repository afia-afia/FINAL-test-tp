/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.emp.gl.heure;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.beans.PropertyChangeEvent;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import org.emp.gl.core.lookup.Lookup;
import org.emp.gl.timer.service.TimerChangeListener;
import org.emp.gl.timer.service.TimerService;
import org.emp.gl.action.RobotAction;

/**
 *
 * @author younes
 */
public class RobotGui extends javax.swing.JFrame  implements TimerChangeListener{

    
    
    public RobotGui() {
       
      setLocation(50, 50);
      setSize(295, 315);
      setVisible(true);
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
       // initComponents();
      
      
        
}
      
       private boolean[][] labyrinthe = {
         {false, false, false, false, false, false, false, false, false, false },
         {false, true, true, true, true, true, true, true, true, false },
         {true, true, true, true, true, true, false , true, true, false },
         {false, false, true, true, false, true, true, true, true, false },
         {false, true, true, true, true, true, true, true, true, false},
         {false, true, true, true, true, true, true, true, true, false },
         {false, true, true, true, true, true, true, false, true,false },
         {false, false, true, true, true, false, true, true, true, false},
         {false, true, true, true, true, true, true, true, true, false},
        
         {false, false, false, false, false, false, false, false, false, false}};

       
  
   /** Position courante en x dans le labyrinthe. */
   private int x=0;

   /** Position courante en y dans le labyrinthe. */
   private int y=2;

  

   /** Énumération pour la direction. */
   private enum Direction
   {
      /** Direction : vers la droite. */
      DROITE,
      /** Direction : vers le bas. */
      BAS,
      /** Direction : vers la gauche. */
      GAUCHE,
      /** Direction : vers le haut. */
      HAUT
   }

   /** La direction courante. */
   private Direction direction;

   
   private static final int TAILLE_PION = 18;

   /** Taille des cases du labyrinthe. */
   private static final int TAILLE_CASE = 20;

   /** Taille du décalage à gauche du labyrinthe. */
   private static final int DEC_GAUCHE = 25;

   /** Taille du décalage en haut du labyrinthe. */
   private static final int DEC_HAUT = 50;


   
        
  
   
   @Override
   public void paint(Graphics g)
   {
      // Parcourt le labyrinthe.
      for(int i = 0; i < this.labyrinthe.length; i++)
      {
         for(int j = 0; j < this.labyrinthe.length; j++)
         {
            // Case libre.
            if(this.labyrinthe[i][j])
            {
               g.setColor(Color.WHITE);
               g.fillRect(DEC_GAUCHE + j * TAILLE_CASE, DEC_HAUT + i * TAILLE_CASE, 
                     TAILLE_CASE, TAILLE_CASE);
               g.setColor(Color.LIGHT_GRAY);
               g.drawRect(DEC_GAUCHE + j * TAILLE_CASE, DEC_HAUT + i * TAILLE_CASE, 
                     TAILLE_CASE, TAILLE_CASE);
            }
            // Mur.
            else
            {
               g.setColor(Color.BLUE);
               g.fillRect(DEC_GAUCHE + j * TAILLE_CASE, DEC_HAUT + i * TAILLE_CASE, 
                     TAILLE_CASE, TAILLE_CASE);
            }
         }
      }

      // Position courante dans le labyrinthe.
      g.setColor(Color.RED);
      g.fillOval(DEC_GAUCHE + 1 + this.x * TAILLE_CASE, DEC_HAUT + 1 + this.y * TAILLE_CASE, 
           TAILLE_PION, TAILLE_PION);
   }

 
 

    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("jLabel1");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addContainerGap(618, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(29, 29, 29)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 68, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(217, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        System.out.println(" hi  ");
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(RobotGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(RobotGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(RobotGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(RobotGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        //</editor-fold>

        /* Create and display the form */
        
        
        
        
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new RobotGui().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    // End of variables declaration//GEN-END:variables

     RobotAction robot=Lookup.getInstance().getService(RobotAction.class);
@Override
    public void propertyChange(PropertyChangeEvent pce) {
      
        TimerService ts = Lookup.getInstance().getService(TimerService.class);
               
          
            if( robot.getX()>=0 && robot.getY()>=0  && robot.getX()<10 && robot.getY()<10&&(labyrinthe[robot.getY()][robot.getX()] == true) ){
             
             this.x=robot.getX();
             this.y=robot.getY();
               
                
                
                
                
              repaint(DEC_GAUCHE + (this.x -1) * TAILLE_CASE, DEC_HAUT + (this.y - 1) * TAILLE_CASE,
              3 * TAILLE_CASE, 3 * TAILLE_CASE);
          
                
            }
            else{
                
                robot.setX(this.x);
                robot.setY(this.y);
                
           }     
           
         
              
    }
}
